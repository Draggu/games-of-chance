# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @auth on FIELD_DEFINITION

directive @balance on FIELD_DEFINITION

directive @constraint(contains: String, endsWith: String, exclusiveMax: Float, exclusiveMin: Float, format: String, max: Float, maxLength: Int, min: Float, minLength: Int, multipleOf: Float, notContains: String, pattern: String, startsWith: String, uniqueTypeName: String) on ARGUMENT_DEFINITION | FIELD_DEFINITION | INPUT_FIELD_DEFINITION

type AuthPayload {
  token: String!
  user: UserEntity!
}

type BalanceEntity {
  balance: Int!
}

union BalanceEntityOrBalanceTooLowError = BalanceEntity | BalanceTooLowError

type BalanceTooLowError {
  chargeAmount: Int!
  currentBalance: Int!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type DiceRollEntity {
  amount: Int!
  chances: Int!
  nonce: Int!
  side: DiceRollSide!
  timestamp: DateTime!
  winning: Int!
  won: Boolean!
}

union DiceRollEntityOrBalanceTooLowError = BalanceTooLowError | DiceRollEntity

input DiceRollInput {
  amount: Int! @constraint(min: 1)
  chances: Int! @constraint(min: 1, exclusiveMax: 100000)
  side: DiceRollSide = LOWER
}

enum DiceRollSide {
  LOWER
  UPPER
}

type DiceSeedEntity {
  clientSeed: String!
  hashedNextServerSeed: String!
  hashedServerSeed: String!
  previousServerSeed: String
}

input LoginInput {
  email: String! @constraint(format: "email")
  password: String!
}

type Mutation {
  deposit(amount: Int!): BalanceEntity! @auth
  login(login: LoginInput!): AuthPayload!
  placeRouletteBet(bet: PlaceRouletteBetInput!): RouletteBetEntityOrBalanceTooLowError @balance @auth
  register(register: RegisterInput!): AuthPayload!
  rollDice(createDiceInput: DiceRollInput!): DiceRollEntityOrBalanceTooLowError @balance @auth
  updateDiceSeed(newSeed: String!): DiceSeedEntity! @auth
  updateUser(updateUser: UpdateUserInput!): UserEntity! @auth
  withdraw(amount: Int!): BalanceEntityOrBalanceTooLowError @balance @auth
}

input PageInput {
  skip: Int = 0 @constraint(min: 0)
  take: Int = 10 @constraint(exclusiveMin: 0, max: 20)
}

input PlaceRouletteBetInput {
  amount: Int! @constraint(exclusiveMin: 0)
  color: RouletteBetColor!
}

type Query {
  diceRollHistory(onlyOwn: Boolean = false, page: PageInput!): [DiceRollEntity!]! @auth
  findUser(id: ID): UserEntity! @auth
  rouletteRollHistory(page: PageInput = {skip: 0, take: 10}): [RouletteRollEntity!]!
  rouletteSeedsHistory(page: PageInput!): [RouletteSeedEntity!]!
  rouletteStats: RouletteStatsEntity!
}

input RegisterInput {
  email: String! @constraint(format: "email")
  name: String!
  password: String!
}

enum RouletteBetColor {
  BLACK
  GREEN
  RED
}

type RouletteBetEntity {
  amount: Int!
  color: RouletteBetColor!
  id: ID!
}

union RouletteBetEntityOrBalanceTooLowError = BalanceTooLowError | RouletteBetEntity

type RouletteRollEntity {
  color: RouletteBetColor!
  nonce: Int!
  timestamp: DateTime!
  winning: Int!
}

type RouletteSeedEntity {
  day: String!
  id: ID!
  isHashed: Boolean!
  privateKey: String!
  publicKey: String!
}

type RouletteStatsEntity {
  blackCount: Int!
  greenCount: Int!
  redCount: Int!
}

type Subscription {
  onRouletteResults: RouletteRollEntity!
  onRouletteRoll: ID!
}

input UpdateUserInput {
  email: String @constraint(format: "email")
  name: String
  password: String
}

type UserEntity {
  balance: Int!
  diceSeed: DiceSeedEntity!
  email: String!
  id: ID!
  name: String!
  password: String!
}